<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CONTENT Physics</title>

  <!-- Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&display=swap" rel="stylesheet">

  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #fff;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    body {
      cursor: crosshair;
    }
  </style>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

    // ---------- settings ----------
    const WORD = "content";
    const SPAWN_EVERY_MS = 250;     // more often
    const MAX_SPAWNS = 20;

    const FONT_FAMILY = "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const FONT_SIZE = 98;           // slightly bigger
    const FONT_WEIGHT = 700;        // Inter Bold
    const TEXT_COLOR = "#000";

    const engine = Engine.create();
    engine.gravity.y = 1.35;        // a bit stronger fall

    const render = Render.create({
      element: document.body,
      engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "#ffffff",
        pixelRatio: Math.min(window.devicePixelRatio || 1, 2)
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // ---------- text measurement ----------
    const measureCanvas = document.createElement("canvas");
    const mctx = measureCanvas.getContext("2d");

    function setMeasureFont() {
      mctx.font = `${FONT_WEIGHT} ${FONT_SIZE}px ${FONT_FAMILY}`;
    }
    setMeasureFont();

    // ---------- walls ----------
    let walls = [];
    function rebuildWalls() {
      for (const w of walls) Composite.remove(engine.world, w);

      const w = window.innerWidth;
      const h = window.innerHeight;
      const t = 90;

      const floor = Bodies.rectangle(w / 2, h + t / 2, w + t * 2, t, { isStatic: true, restitution: 0.2 });
      const ceil = Bodies.rectangle(w / 2, -t / 2, w + t * 2, t, { isStatic: true, restitution: 0.2 });
      const left = Bodies.rectangle(-t / 2, h / 2, t, h + t * 2, { isStatic: true, restitution: 0.2 });
      const right = Bodies.rectangle(w + t / 2, h / 2, t, h + t * 2, { isStatic: true, restitution: 0.2 });

      walls = [floor, ceil, left, right];
      Composite.add(engine.world, walls);
    }
    rebuildWalls();

    // ---------- helpers ----------
    function rand(min, max) { return min + Math.random() * (max - min); }

    function spawnWord() {
      setMeasureFont();
      const metrics = mctx.measureText(WORD);
      const textW = Math.ceil(metrics.width);
      const textH = Math.ceil(FONT_SIZE * 0.95);

      // spawn anywhere inside the viewport (with padding so it doesn't clip immediately)
      const padX = Math.max(40, textW * 0.35);
      const padY = 60;
      const x = rand(padX, window.innerWidth - padX);
      const y = rand(padY, Math.min(window.innerHeight * 0.45, window.innerHeight - padY));

      const body = Bodies.rectangle(x, y, textW, textH, {
        restitution: 0.68,
        friction: 0.12,
        frictionAir: 0.01,
        density: 0.0023,
        chamfer: { radius: 12 },
        render: {
          fillStyle: "transparent",
          strokeStyle: "transparent",
          lineWidth: 0
        }
      });

      Body.setAngle(body, rand(-0.95, 0.95));
      Body.setAngularVelocity(body, rand(-0.06, 0.06));
      Body.setVelocity(body, { x: rand(-4, 4), y: rand(-2, 2) });

      body.plugin = body.plugin || {};
      body.plugin.text = { value: WORD };

      Composite.add(engine.world, body);
      return body;
    }

    // ---------- spawn loop (stop after 20) ----------
    let spawnCount = 0;
    let spawnTimer = setInterval(() => {
      spawnWord();
      spawnCount++;
      if (spawnCount >= MAX_SPAWNS) {
        clearInterval(spawnTimer);
        spawnTimer = null;
      }
    }, SPAWN_EVERY_MS);

    // ---------- draw text over bodies ----------
    Events.on(render, "afterRender", () => {
      const ctx = render.context;

      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = TEXT_COLOR;
      ctx.font = `${FONT_WEIGHT} ${FONT_SIZE}px ${FONT_FAMILY}`;

      const bodies = Composite.allBodies(engine.world);
      for (const b of bodies) {
        if (!b.plugin?.text) continue;
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);
        ctx.fillText(b.plugin.text.value, 0, 0);
        ctx.restore();
      }
      ctx.restore();
    });

    // ---------- resize ----------
    function handleResize() {
      render.canvas.width = window.innerWidth * render.options.pixelRatio;
      render.canvas.height = window.innerHeight * render.options.pixelRatio;
      render.canvas.style.width = window.innerWidth + "px";
      render.canvas.style.height = window.innerHeight + "px";
      Render.setPixelRatio(render, render.options.pixelRatio);
      Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: window.innerWidth, y: window.innerHeight } });
      rebuildWalls();
    }
    window.addEventListener("resize", handleResize);

    // ---------- bonus: click to spawn (still respects MAX_SPAWNS) ----------
    window.addEventListener("pointerdown", () => {
      if (spawnCount >= MAX_SPAWNS) return;
      spawnWord();
      spawnCount++;
      if (spawnCount >= MAX_SPAWNS && spawnTimer) {
        clearInterval(spawnTimer);
        spawnTimer = null;
      }
    });
  </script>
</body>

</html>